#|
(define return #f)

(+ 1 (call/cc
       (lambda (cont)
         (set! return cont)
         1)))

(return 22)
23

;; crazy!

Now what happened here? The return procedure did the same thing it did above:
The 22 passed to return is used as the return value of the call/cc call. This
return value is then added to 1, which yield 23. And this is what we got. We
never returned from the call to return, but returned from the addition way
above there.

The difference here is that we re-entered the computation from outside,
we did not just leave it. This is a big brain-twister. Be sure to understand it!

|#
(define (hefty-computation do-other-stuff)
  (let loop ((n 5))
    (display "Hefty computation: ")
    (display n)
      (newline)
      (set! do-other-stuff (call/cc do-other-stuff))
      (display "Hefty computation (b)")
      (newline)
      (set! do-other-stuff (call/cc do-other-stuff))
      (display "Hefty computation (c)")
      (newline)
      (set! do-other-stuff (call/cc do-other-stuff))
      (if (> n 0)
          (loop (- n 1)))))

(define (superfluous-computation do-other-stuff)
    (let loop ()
      (for-each (lambda (graphic)
                  (display graphic)
                  (newline)
                  (set! do-other-stuff (call/cc do-other-stuff)))
                '("Straight up." "Quarter after." "Half past."  "Quarter til."))
      (loop)))

(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))

; 5

(call-with-current-continuation
    (lambda (exit)
      (for-each (lambda (x)
             (if (eq? x 'nuclear)
               (exit x)
               (symbol->string x)))
         '(this is a nuclear bomb in your garage))))

(define divide1
 (lambda (pred? ls)
   (letrec ([proc1
              (lambda (ls)
                (cond
                  [(null? ls) ls]
                  [(pred? (car ls))
                      (cons (car ls) (proc1 (cdr ls)))]
                  (else
                   (begin
                     (cons (car ls) (proc2 (cdr ls)))
                     (proc1 (cdr ls))
                     ))))]
            [proc2
              (lambda (ls)
                (cond
                  [(null? ls) ls]
                  [(pred? (car ls))
                     (begin
                        (cons (car ls) (proc1 (cdr ls)))
                        (proc2 (cdr ls)))
                       ]
                  (else (cons (car ls) (proc2 (cdr ls))))))])
     (list (proc1 ls) (proc2 ls)))))  ;; this is fucking amazing?
#|

so it hits the 0 and conses it back recursively to proc1, simple
it hits the 1 and first cons that to proc2 cdr ls, THEN performs proc1 cdr ls...
the question is, is this single or multiple pass?
|#




;inefficient, fix this?

(define add2 #f)
(+ 2 (call/cc (lambda (cont) (set! add2 cont) 3)))





(define divide2
  (lambda (pred? ls)
    (let-values ([(ls1 ls2) (partition pred? ls)])
      (list ls1 ls2))))

;; (let ((delayed (delay (+ 5 6))))
 ;   (force delayed))    11
(define (foo1)
  (values 1 2 3))

(let-values (((a b c) (foo1)))
  (list a b c))


(define foo2
 (lambda (k)
  (k 1 2 3)))

;(foo2 (lambda (a b c)
 ;       (list a b c)))
 ; (1 2 3)

(define divide3
  (lambda (pred? ls)
   (define-values (a b)
    (let loop ((ls ls))
      (if (null? ls) (values '() '())
          (call-with-values
            (lambda ()
              (loop (cdr ls)))
            (lambda (a b)
              (if (pred? (car ls))
                  (values (cons (car ls) a) b)
                  (values a (cons (car ls) b))))))))
    (list a b)))

(define divide4
  (lambda (pred? ls)
   (let-values ([(a b)
                   (let loop ((ls ls))
                    (if (null? ls)
                        (values '() '())
                        (call-with-values
                         (lambda ()
                           (loop (cdr ls)))
                         (lambda (a b)
                          (if (pred? (car ls))
                             (values (cons (car ls) a) b)
                             (values a (cons (car ls) b)))))))])
     (list a b))))





(define generate-distances
  (lambda (coor disfunct data)
    (let loop ((ls data))          ;; gives us a list of distances and addresses
      (if (null? ls) ls
        (cons (list (disfunct coor (cadar ls)) (car ls))
         (loop (cdr ls)))))))




(define divide
  (lambda (pred? ls)
    (let loop ((ls ls) (acc1 '()) (acc2 '()))
     (cond
      [(null? ls) (list acc1 acc2)]
      [(pair? (car ls))        ;; that is, in case ls is an association list, as
         (if (pred? (caar ls))    ;; is generated by generated-distances
               (loop (cdr ls) (cons (car ls) acc1) acc2)
               (loop (cdr ls) acc1 (cons (car ls) acc2)))]
      (else
       (if (pred? (car ls))
               (loop (cdr ls) (cons (car ls) acc1) acc2)
               (loop (cdr ls) acc1 (cons (car ls) acc2))))))))


(define quicksort
  (lambda (rel? ls)
   (if (or (null? ls) (null? (cdr ls)))
       ls
    (let*
      ([goo (car ls)]

       [rel?xgoo (lambda (x)
          (if (pair? (car ls))
              (rel? x (car goo))
              (rel? x goo)))]

       [pars (divide rel?xgoo (cdr ls))])

         (join
           (quicksort rel? (car pars))
           goo
           (quicksort rel? (cadr pars)))))))

(define ikuraarg
        (lambda args
           (length args)))             ; wowwowow

(define majority
  (lambda (ls labels)
    (let loop ((ls ls) (counts (make-list (length labels))))
      (let ((m (memi labels (caar ls))))
            (cond
              [(null? ls) counts]
              [m
                (map
                  (lambda (x)
                    (if (equal? m (list-ref counts x)) (add1 x) x)) counts)]
              (else
               (loop (cdr ls) counts)))))))




(define memi
 (lambda (ls x)
  (let loop ((ls ls) (i 0))  ;; gives the index of an element ofa list
   (cond
    [(null? ls) #f]
    [(equal? x (car ls)) i]
    (else
     (loop (cdr ls) (add1 i)))))))







;; the question is, how do we let n number of variables?